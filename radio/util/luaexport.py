#!/usr/bin/env python
# -*- coding: utf-8 -*-


import sys
import os
import traceback
import time

PREC1 = 10
PREC2 = 100

CONSTANT_VALUE = ""
dups_cnst = []
dups_name = []
exports = []
exports_multiple = []
exports_script_outputs = []
exports_extra = []

warning = None
error = None

def checkName(name):
  global warning
  if name in dups_name:
    print "WARNING: Duplicate name %s found for constant %s" % (name, CONSTANT_VALUE)
    warning = True
  dups_name.append(name)
  if name != name.lower():
    print "WARNING:Name not in lower case %s found for constant %s" % (name, CONSTANT_VALUE)
    warning = True


def LEXP(name, description):
  # print "LEXP %s, %s" % (name, description)
  checkName(name)
  exports.append( (CONSTANT_VALUE, name, description) )

def LEXP_TELEMETRY(name, description):
  # print "LEXP %s, %s" % (name, description)
  checkName(name)
  exports.append( ("MIXSRC_FIRST_TELEM-1+"+CONSTANT_VALUE, name, description) )

def LEXP_MULTIPLE(nameFormat, descriptionFormat, firstValue, numOfValues):
  # print "LEXP_MULTIPLE %s, %s, %s, %s" % (nameFormat, descriptionFormat, firstValue, numOfValues)
  first = int(firstValue)
  last = first + int(numOfValues) - 1
  for v in range(first, last+1):
    name = nameFormat % v
    # print name
    checkName(name)
  exports_multiple.append( (CONSTANT_VALUE, nameFormat, descriptionFormat, first, last) )

def LEXP_EXTRA(name, description, value, condition = "true"):
  # print "LEXP_EXTRA %s, %s, %s, %s" % (name, description, value, condition)
  checkName(name)
  exports_extra.append( (CONSTANT_VALUE, name, description, value, condition) )
  # extra also added to normal items to enable searching
  exports.append( (CONSTANT_VALUE, name, description) )


inputFile = sys.argv[1]
outputFile = sys.argv[2]
print "Input file %s" % inputFile
print "Output file %s" % outputFile

inp = open(inputFile, "r")

while True:
  line = inp.readline()
  if len(line) == 0:
    break
  line = line.strip('\r\n')
  line = line.strip()
  #print "line: %s"  % line

  parts = line.split('LEXP')
  #print parts
  if len(parts) != 2:
    print "Wrong line: %s" % line
    continue
  cmd = 'LEXP' + parts[1]
  cnst = parts[0].rstrip(', ')
  if cnst.find('=') != -1:
    # constant contains =
    cnst = cnst.split('=')[0].strip()
  #print "Found constant %s with command: %s" % (cnst, cmd)
  try:
    CONSTANT_VALUE = cnst
    # if CONSTANT_VALUE in dups_cnst:
    #   print "WARNING: Duplicate CONSTANT_VALUE found: %s" % CONSTANT_VALUE
    #   warning = True
    #   continue
    # dups_cnst.append(CONSTANT_VALUE)
    eval(cmd)
  except:
    print "ERROR: problem with the definition: %s" % line
    traceback.print_exc()
    error = True

inp.close()

out = open(outputFile, "w")

out.write("//This file was generated by luaexport.py script on %s\n\n\n" % time.asctime())

header = """
struct LuaField {
  uint16_t id;
  const char * name;
  const char * desc;
  //const uint8_t attr;
};

struct LuaMultipleField {
  uint16_t id;
  const char * name;
  const char * desc;
  uint8_t start;
  uint8_t end;
};

"""
out.write(header)

out.write("""
// The list of Lua fields
// this aray is alphabetically sorted by the second field (name)
const LuaField luaFields[] = { 
""")
exports.sort(key = lambda x: x[1])  #sort by name
data = ["  {%s, \"%s\", \"%s\"}" % export for export in exports]
out.write(",\n".join(data))
out.write("\n};\n\n")
print "Generated %d items in luaFields[]" % len(exports)

out.write("""
// The list of Lua fields that have a range of values
const LuaMultipleField luaMultipleFields[] = {
""")
data = ["  {%s, \"%s\", \"%s\", %d, %d}" % export for export in exports_multiple]
out.write(",\n".join(data))
out.write("\n};\n\n")
print "Generated %d items in luaMultipleFields[]" % len(exports_multiple)

#code generation for extra fields
case = """    case %s:
      if (%s) {
        lua_pushnumber(L, %s);
        return 1;
      }
      break;"""
case_clauses = [case % (cnst, condition, value) for (cnst, name, description, value, condition) in exports_extra]
case_body = "\n".join(case_clauses)
func_body = """
extern lua_State *L;

// The handling of extra Lua fileds that are not
// accesible by the getValue()
static int luaGetExtraValue(int src)
{
  switch (src) {
%s
  }
  return 0;
}

""" % case_body
out.write(func_body)
print "Generated %d condtions in luaGetExtraValue()" % len(exports_extra)


out.close()

if warning:
  sys.exit(1)
elif error:
  os.remove(outputFile)
  sys.exit(2)
sys.exit(0)
